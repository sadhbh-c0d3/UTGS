#ifndef __INCLUDED_USELESS_HOLDER_H__
#define __INCLUDED_USELESS_HOLDER_H__

/*
**  $Id: Holder.h,v 1.11 2003/07/29 17:52:08 koolas Exp $
**
**  NAME
**      Holder
**
**  PURPOSE
**      Pack values, variables or packed-BasicHolders.
**      Holder enables you to make objects wich can be casted to specified type.
**      You can use it in three general cases:
**      1)    You need to pass reference to some unreferabe type.
**                   my_function( [const char * &] PackValue2Holder("mamma_mia") );
**
**      2)    You need to pass some variable, while you are not able to
**                   my_function( [int] PackVariable2Holder( (int)my_x ) );
**
**      3)    You want some function to decide which value is now valid 
**                   my_function( [int] PackFuncPtr2Holder
**                                  ( 
**                                      PackFunctorR
**                                      (
**                                          UnaryRCall(&my_object, &its::method, (int)0 ),
**                                          (int)0
**                                      ),
**                                      PackVariable(my_x),
**                                      (int)0 
**                                  ) 
**                              );
**
**      You can use this shortcut
**                   my_function( PackTranslator( &my_object, &its_method, PackVariable(my_x), (int)0 );
**
**
**
**      In above example I assume "using namespace Useless"
**      [Type] means that you need some holder-object that can be cast to "Type"
**      ! You don't put it in code offcourse !
**      One may got confussed about (3) example, so here is explanation:
**      You want to create holder-object that can be cast to type "int", but you also
**      want that "int" to be generated by some function. So, you need to pass
**      this function to holder, which would remember it, and execute when cast method
**      is executed. Best way to pass function is to pack it into Packed Functor with
**      capability of returning value. This Packed Functor needs to be initialized with
**      Functor and some argument, which will be used while its execution. To create
**      Functor with capability of returning value, use function such as "UnaryCall".
**      Pass it pointer-to-object and poiner-to-method. Here I used VariableHolder
**      as second argument of PackFunctorR. It will give me chance to alter "my_x"
**      variable, which will cause in different return value of PackedFunctor and
**      different our-functor-holder casting value will occur. 
**
**
**  AUTHOR(S)
**      Sadhbh Code (https://github.com/sadhbh-c0d3)
**
**  USAGE
**      HolderBase<Type> * PackValue2Holder(Type value)
**      HolderBase<Type> * PackVariable2Holder(Type &variable)
**      HolderBase<Type> * PackFunctor2Holder( PkFuncR<Type> pkfunctor, (Type)0 )
**      HolderBase<Type> * PackTranlator( CalleePtr, Type (Callee::*Method)(Type1), Type1, Type )
*/
#include "PackedFunctor.h"
#include "Useless/Util/SPointer.h"

namespace Useless
{

/*! \ingroup Functors
 *  \defgroup BasicHolders
 */

/*! \ingroup BasicHolders
 *  Holds Type by Value
 */
template< class Type >
class ValueHolder
{
    public:
        ValueHolder() {}
        ValueHolder(const Type value): _held_value(value) {}
        operator Type&() const { return _held_value; }
    private:
        mutable Type _held_value;
};


/*! \ingroup BasicHolders
 *  Holds Type by Reference
 */
template< class Type >
class VariableHolder
{
    public:
        VariableHolder(): _held_variable(0) {}
        VariableHolder(Type& variable) : _held_variable(&variable) {}
        operator Type&() const { return *_held_variable; }
        bool operator()() { return _held_variable; }
    private:
        mutable Type* _held_variable;
};

/*! \ingroup BasicHolders
 *  Evaluates Value via Functor
 */
template< class Type, class FType >
class FunctorHolder
{
    public:
        FunctorHolder() {}
        FunctorHolder( const FType &functor ) : _functor(functor) {}
        operator Type() const  { return _functor(); }

    private:
        mutable FType    _functor;
};


/*! \ingroup BasicHolders
 *  Holds Type by deferencing PType (unary operator*)
 */
template< class Type, class PType >
class DeferenceHolder
{
    public:
        DeferenceHolder(): _pointer(0) {}
        DeferenceHolder(PType pointer) : _pointer(pointer) {}
        operator Type&() const { return *_pointer; }
    private:
        mutable PType _pointer;
};


/*! \ingroup BasicHolders
 *  Evaluates Value via Functor given by pointer
 */
template< class Type, class FTypePtr >
class DeferenceFunctorHolder
{
    public:
        DeferenceFunctorHolder() {}
        DeferenceFunctorHolder( FTypePtr functor ) : _functor(functor) {}
        operator Type() const { return (*_functor)(); }

    private:
        mutable FTypePtr _functor;
};


//////////////////////////////////////////////////////
//    Holder Creators
//
/*! \ingroup BasicHolders*/
/*! @name Packing values, variables, deferences, BasicHolders (translators)
 */
/*@{*/

/*! Pack copy of given object */
template< class Type > inline ValueHolder<Type>

PackValue2Holder(const Type value)
{
    return ValueHolder<Type>(value);
} 


/*! Pack reference to place where real object can be found */
template< class Type > inline VariableHolder<Type>

PackVariable2Holder(Type &variable)
{
    return VariableHolder<Type>(variable);
} 


/*! Pack pointer to place where real object can be found */
template< class Type > inline DeferenceHolder<Type,Type*>

PackDeference2Holder(Type *pointer)
{
    return DeferenceHolder<Type,Type*>(pointer);
}


/*! Pack functor-pointer ( given by Useless::PkFuncR<Type> )
 *  into DeferenceFunctorHolder
 */
template< class Type > inline DeferenceFunctorHolder<Type, Useless::PkFuncR<Type> >

PackFuncPtr2Holder( const Useless::PkFuncR<Type> &functor )
{
    return DeferenceFunctorHolder<Type, Useless::PkFuncR<Type> >( functor );    
}


/*! Pack functor-object [ any object with defined operator() ] */
template< class Type, class FuncObj > inline FunctorHolder<Type, FuncObj>

PackFunctor2Holder( const FuncObj &foo, const Type& )
{
    return FunctorHolder<Type, FuncObj>(foo);
}


/*! Pack functor to  be used to translate one data type to another */
template< class DestType, class SrcType, class CalleePtr, class Callee, class Ret, class MType>
inline DeferenceFunctorHolder<DestType, Useless::PkFuncR<DestType> >

PackTranslator ( 
                    const CalleePtr & trPtr,
                    Ret (Callee::*trMet)(MType),
                    const SrcType& argument,
                    const DestType& dest_type
               )
{
    return 
    
    DeferenceFunctorHolder<DestType, Useless::PkFuncR<DestType> >
    (
        PackFunctorR
        (
            UnaryRCall(trPtr, trMet, Ret() ), argument, dest_type
        )
    );
    
}
/*@}*/

/*! Pack functor to  be used to translate one data type to another (const version) */
template< class DestType, class SrcType, class CalleePtr, class Callee, class Ret, class MType>
inline DeferenceFunctorHolder<DestType, Useless::PkFuncR<DestType> >

PackTranslator ( 
                    const CalleePtr & trPtr,
                    Ret (Callee::*trMet)(MType) const,
                    const SrcType& argument,
                    const DestType& dest_type
               )
{
    return 
    
    DeferenceFunctorHolder<DestType, Useless::PkFuncR<DestType> >
    (
        PackFunctorR
        (
            UnaryRCall(trPtr, trMet, Ret() ), argument, dest_type
        )
    );
    
}
/*@}*/


}; 
#endif //__INCLUDED_USELESS_HOLDER_H__
